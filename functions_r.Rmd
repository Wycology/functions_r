---
title: "<center>**Functional Programming in `R`**</center>"
author: "<center>Wyclife Agumba Oluoch</center>"
date: '<center>`r Sys.time()`</center>'
output: 
    html_document:
      toc: true
      toc_depth: 2
      toc_float: true
      theme: cerulean
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Functional programing in `R`

Virtually very time one uses `R`, a function *must* be used. It is not enough to use a function, it is enough to understand what the function does and even better still to tweak the function to suit your needs or even develop your own function(s).

Here is a function that takes a number and squares it:

```{r}
square <- function(a) a**2
square(3)
```

It can be written using curly braces as follows:

```{r}
square <- function(b){
  b**2
}
square(4)
```

The same can also be written as follows:

```{r}
square <- function(c){
  product <- c**2
  return(product)
}
square(8)
```

The same can be presented as:

```{r}
square <- function(d){
  product <- d**2
  print(product)
}
square(5)
```

This is performing the same task:

```{r}
square <- function(e){
  product <- e**2
  (product)
}
square(9)
```

The same can be returned using the show:

```{r}
square <- function(f){
  product <- f**2
  show(product)
}
square(9)
```

Now I want the formula to return half the square root of the number:

```{r}
square_root <- function(b){
  product <- b^0.5
  return(product/2)
}
square_root(9)
```

The function can also take a list and return their outputs accordingly.

```{r}
square(1:10)
```
or even

```{r}
square_root(c(26, 1:15, 158))
```
We can even dig into a list and find the result we want.

```{r}
m <- list(12, 18, 345)
square_root(m[[3]])
```

# Rescale function

Here we are going to create a function that will take a vector, calculate mean, calculate standard deviation, then divide deviations of values from mean by standard deviation

```{r}
rescale <- function(x){
  m <- mean(x)
  s <- sd(x)
  (x - m) / s
}
rescale(c(52, 58, 46, 99))
```

```{r}
rescale <- function(x, only_translate){
  m <- mean(x)
  translated <- x - m
  if (only_translate) return(translated)
  s <- sd(x)
  translated / s
}

rescale(x = 1:4, only_translate = TRUE)
```

```{r}
rescale <- function(x, only_translate){
  m <- mean(x)
  translated <- x - m
  if (only_translate) return(translated)
  s <- sd(x)
  translated / s
}

rescale(x = 1:4, only_translate = FALSE)
```

Since we have named the arguments in the function call, the order normally does not matter. That is we can start with the only_translate argument before including the x argument as follows:

```{r}
rescale( only_translate = TRUE, x = 1:4)
```
In case of only two arguments being fed into a function, provided one is named, the other may not necessarily be named too. For example:

```{r}
rescale(x = 1:4, TRUE)
rescale(TRUE, x = 1:4)
rescale(1:4, only_translate = T)
rescale(only_translate = T, 1:4)
```
It is possible j to give few unique initials of the name of the argument and the function will run successfully. For example, in our `rescale` function, the arguments start with x and o, so only stating the first name character is enough as follows:

```{r}
rescale(1:4, o = T)
rescale(o = T, 1:4)
```

The method above is suited for short codes in R and should not be used when writing programs or packages as the users may be confused. Avoid it.

# Default parameters

It is possible to give a function default parameter when defining it. This can be changed by the user when giving appropriate parameter to the argument to show results otherwise.

```{r}
rescale <- function(x, only_translate = FALSE){
  m <- mean(x)
  translated <- x - m
  if(only_translate) return(translated)
  s <- sd(x)
  translated / s
}
```


Now, since the default value of only_translate has been given, we can only supply the vector x and nothing for only_translate and the FALSE parameter for that argument will be run under the hood.

```{r}
rescale(1:4) # This runs with only_translate being taken as FALSE by default.
```

# Gobble up everything else argument

There is the ... variable in R which can be used in a function. It is normally applicable when calling a function within a function and you wish to use all functions from the other function.

```{r}
rescale <- function(x, ...){
  m <- mean(x, ...)
  s <- sd(x, ...)
  (x - m) / s
}

rescale(1:4)
```

```{r}
x <- c(NA, 1:3)
rescale(x)
```

```{r}
x <- c(NA, 1:3)
rescale(x, na.rm = TRUE)
```
The parameter ... takes any named parameter at all. However, if it is not included in a function, then you are only limited to arguments in the function and cannot add anything else like `na.rm = T`.

```{r}
some_function <- function(x) x
other_function <- function(x, ...) x
# some_function(1:4, foo = "bar") # This does not run because there was no allowance.
other_function(1:4, foo = "bar")

```

```{r}
f <- function(...) list(...)
g <- function(x, y, ...) f(...)
g(x = 1, y = 2, z = 3, w = 4)
```

# References
